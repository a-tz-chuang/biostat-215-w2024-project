---
title: "Biostat M215 Final Project"
author: "Rina Arputhasamy, Andrew Chuang, Carolyn Winskill, Kyle Wu"
date: "2024-03-19"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Biostatistics M215: Final Project

## Libraries: 

```{r}
#Relevant libraries:
library(survival)
library(descr)
library(PAmeasures)
library(tidyverse)
library(kableExtra)
library(pec)
library(MASS)
library(gtsummary)
library(SurvMetrics)
library(gt)

data_directory <- "functions/"
source(paste0(data_directory, "pam.survreg.update.R"))
```

## Data Preparation

```{r data_load}
data(cancer, package = "survival")
n <- nrow(rotterdam)
```

```{r train_test_split}
# train-test split
test_p <- 0.15
set.seed(215) #cw added
test_indx <- sample(n, n * test_p)
rotterdam_test <- rotterdam[test_indx,]
rotterdam_train <- rotterdam[!seq_len(n) %in% test_indx,]
```

## Descriptive Statistics

```{r}
rot.cont <- rotterdam %>% select(age, nodes, pgr, er, rtime, dtime) 
rot.cat <- rotterdam %>% select(year, meno, size, hormon, chemo, recur, death, grade)

tbl1 <- c("mean", "sd", "median", "min", "max") %>%
  lapply(
    function(.x) {
      tbl_summary(
        data = rot.cont, 
        statistic = everything() ~ paste0("{", .x, "}"),
        include = c(age, nodes, pgr, er, rtime, dtime),
        missing = "no"
      ) %>%
        modify_header(all_stat_cols() ~ glue::glue("**{.x}**"))
    }
  ) %>%
  # Merge tables to get a column for each summary statistic
  tbl_merge() %>%
  modify_spanning_header(everything() ~ NA) %>%
  modify_footnote(everything() ~ NA) %>% 
  modify_caption("**Table 1: Continuous Patient Characteristics**")
#gt::gtsave(as_gt(tbl1), file = file.path(getwd(), "tbl1.png"))
#tbl1
```

```{r}
tbl2 <- rot.cat %>%
  tbl_summary(
    statistic = list(
      all_continuous() ~ "{mean} ({sd})",
      all_categorical() ~ "{n} / {N} ({p}%)"
    ),
    digits = all_continuous() ~ 2,
    missing_text = "(Missing)"
  ) %>%
  modify_caption("**Table 2: Categorical Patient Characteristics**")
#gt::gtsave(as_gt(tbl2), file = file.path(getwd(), "tbl2.png"))
#tbl2
```


## Kaplan Meier Plots

```{r}
km<-survfit(Surv(dtime, death)~1,conf.type="log-log",data=rotterdam)
summary(km)

plot(km,conf.int=F,mark.time=F,
     xlab="time (days)",
     ylab="probability",
     main="Kaplan-Meier estimates of time to death")
```

CW: make plot more visually appealing? add KM plots stratified by predictors like menopausal status, tumor size, differentiation grade, hormonal treatment?

## Log-rank tests 

```{r}
survdiff(Surv(dtime, death)~meno,data=rotterdam)
```
CW: need univariate Cox models to get unadjusted hazard ratios?

## Full Models and Prediction Accuracy Measures 

### Cox PH and PAM: 

```{r}
# Fit a multiple Cox PH model with age and edema
fit.coxph <- coxph(Surv(dtime, death) ~ age + meno + size + grade + nodes + pgr + er + hormon + chemo, 
                   data = rotterdam_train, x=TRUE,y=TRUE)
summary(fit.coxph)
# R.squared and L.squared of Cox PH model
pam.coxph(fit.coxph)
concordance(fit.coxph, timewt = "n/G2")$concordance
```

### Exponential AFT Model: 

```{r}
fit.exp <- survreg(Surv(dtime, death) ~ age + meno + size + 
                     grade + nodes + pgr + er + hormon + chemo,
                   data = rotterdam_train, dist="exponential",
                   x = TRUE, y = TRUE)
summary(fit.exp)
# R.squared and L.squared of exponential model
# when data has factors (size), need to pass data directly as shown below
pam.survreg(fit.exp, x.mat = rotterdam_train)
concordance(fit.exp, timewt = "n/G2")$concordance
```

### Weibull AFT Model: 

```{r}
fit.wei <- survreg(Surv(dtime, death) ~ age + meno + size + 
                     grade + nodes + pgr + er + hormon + chemo,
                   data = rotterdam_train, dist="weibull",
                   x = TRUE, y = TRUE)
summary(fit.wei)
# R.squared and L.squared of exponential model
# when data has factors (size), need to pass data directly as shown below
pam.survreg(fit.wei, x.mat = rotterdam_train)
concordance(fit.wei, timewt = "n/G2")$concordance
```

### Lognormal AFT Model: 

```{r}
fit.lognormal <- survreg(Surv(dtime, death) ~ age + meno + size + 
                           grade + nodes + pgr + er + hormon + chemo, 
                   data = rotterdam_train, dist="lognormal",
                   x = TRUE, y = TRUE)
summary(fit.lognormal)
# R.squared and L.squared of the lognormal model
pam.survreg(fit.lognormal, x.mat = rotterdam_train)
concordance(fit.lognormal, timewt = "n/G2")$concordance
```

```{r}
tbl3 <- rbind(data.frame(c(Model = "Cox PH", pam.coxph(fit.coxph), 
  Concordance = concordance(fit.coxph, timewt = "n/G2")$concordance)), 
  data.frame(c(Model = "Exponential AFT", pam.survreg(fit.exp, x.mat = rotterdam_train), 
  Concordance = concordance(fit.exp, timewt = "n/G2")$concordance)),
  data.frame(c(Model = "Weibull AFT", pam.survreg(fit.wei, x.mat = rotterdam_train), 
  Concordance = concordance(fit.wei, timewt = "n/G2")$concordance)),
  data.frame(c(Model = "Lognormal AFT", pam.survreg(fit.lognormal, x.mat = rotterdam_train),
  Concordance = concordance(fit.lognormal, timewt = "n/G2")$concordance))) %>%
  gt::gt() %>% gt::tab_header("Table 3: Prediction Accuracy Measures") %>%
  tab_style(style = cell_text(weight = "bold"),
                locations = list(cells_column_labels(), cells_title()))
#gt::gtsave(tbl3, file = file.path(getwd(), "tbl3.png"))
#tbl3
```

## Model Selection

### Cox Regression

We first consider variable selection under the Cox proportional hazards model.

Stepwise forward selection via AIC:
```{r AIC_forward_selection}
full_model_formula <- Surv(dtime, death) ~ age + meno + size + 
                           grade + nodes + pgr + er + hormon + chemo
null_model_formula <- Surv(dtime, death) ~ 1
rot_sfAIC <- stepAIC(coxph(null_model_formula, data = rotterdam_train,
                            x = TRUE, y = TRUE),
                     full_model_formula,
                     direction = "forward", k = 2)
summary(rot_sfAIC)
pam.coxph(rot_sfAIC)
concordance(rot_sfAIC, timewt = "n/G2")$concordance
```

Stepwise backward selection via AIC:
```{r AIC_backward_selection}
rot_sbAIC <- stepAIC(coxph(full_model_formula,
                             data = rotterdam_train,
                             x = TRUE, y = TRUE),
                     full_model_formula,
                     direction = "backward", k = 2)

summary(rot_sbAIC)
pam.coxph(rot_sbAIC)
concordance(rot_sbAIC, timewt = "n/G2")$concordance
```

Forward and backward selection via AIC result in the same model.

Stepwise forward selection via BIC:
```{r BIC_forward_selection}
rot_sfBIC <- stepAIC(coxph(null_model_formula, data = rotterdam_train,
                           x = TRUE, y = TRUE),
                     full_model_formula,
                     direction = "forward", k = log(n))
summary(rot_sfBIC)
pam.coxph(rot_sfBIC)
concordance(rot_sfBIC, timewt = "n/G2")$concordance
```

Stepwise backward selection via BIC:
```{r BIC_backward_selection}
rot_sbBIC <- stepAIC(coxph(full_model_formula,
                           data = rotterdam_train,
                           x = TRUE, y = TRUE),
                     full_model_formula,
                     direction = "backward", k = log(n))
summary(rot_sbBIC)
pam.coxph(rot_sbBIC)
concordance(rot_sbBIC, timewt = "n/G2")$concordance
```

### Cox PH LASSO

We fit a LASSO model (selecting penalty via 10-fold cross-validation) and attach the resulting coefficients to a coxph object so that we can call survival::concordance:

```{r}
library(ncvreg)
X <- rotterdam_train[, c("age", "meno", "size", "grade", "nodes", "pgr",
                         "er", "hormon", "chemo")]
X$`size20-50` <- ifelse(X$size == "20-50", 1, 0)
X$`size>50` <- ifelse(X$size == ">50", 1, 0)
X$size <- NULL
y <- Surv(rotterdam_train$dtime, rotterdam_train$death)
rot_cvlasso <- cv.ncvsurv(X, y,
                          nfolds = 10, nlambda = 50, penalty = "lasso")
rot_lasso <- ncvsurv(X, y, penalty = "lasso", lambda = rot_cvlasso$lambda.min)
lasso_beta <- coef(rot_lasso)
names(lasso_beta) <- colnames(X)
lasso_temp <- coxph(full_model_formula, data = rotterdam_train,
                    x = TRUE, y = TRUE)
lasso_beta <- lasso_beta[match(names(coef(lasso_temp)), names(lasso_beta))]
lasso_temp$coefficients <- lasso_beta
concordance(lasso_temp, timewt = "n/G2", newdata = rotterdam_train)
```

### AFT

#### Weibull AFT

```{r}
weiAFT_sbAIC <- stepAIC(survreg(full_model_formula,
                                data = rotterdam_train, dist="weibull",
                                x = TRUE, y = TRUE),
                        data = rotterdam_train,
                        full_model_formula,
                        direction = "backward", k = 2)
```
#### Exponential AFT

```{r}
exAFT_sbAIC <- stepAIC(survreg(full_model_formula,
                                data = rotterdam_train, dist="exponential",
                                x = TRUE, y = TRUE),
                        data = rotterdam_train,
                        full_model_formula,
                        direction = "backward", k = 2)
```

#### Lognormal AFT

```{r}
lognormAFT_sbAIC <- stepAIC(survreg(full_model_formula,
                                data = rotterdam_train, dist="lognormal",
                                x = TRUE, y = TRUE),
                        data = rotterdam_train,
                        full_model_formula,
                        direction = "backward", k = 2)
```

## Adding Relapse as Time-dependent Covariate

Suppose we add the time-dependent relapse indicator as a covariate.

```{r}
cut_points <- sort(unique(rotterdam_train[rotterdam_train$death == 1,]$dtime))
rottrain_t <- survSplit(Surv(dtime, death) ~ ., data = rotterdam_train,
                   cut = cut_points, end = "end", start = "start")
rottrain_t$has_relapsed <- rottrain_t$end >= rottrain_t$rtime & rottrain_t$recur == 1
full_modelt_formula <- Surv(start, end, death) ~ age + meno + size + 
  grade + nodes + pgr + 
  er + hormon + chemo + has_relapsed
rott_coxph <- coxph(full_modelt_formula, data = rottrain_t, x = TRUE, y = TRUE)
```

Cox multiplicative hazards model backward selection via BIC:

```{r, eval = FALSE}
rott_sbBIC <- stepAIC(rott_coxph,
                      full_modelt_formula,
                      direction = "backward", k = log(n))
```

Cox multiplicative hazards model forward selection via AIC:

```{r, eval = FALSE}
rott_sfAIC <- stepAIC(coxph(Surv(start, end, death) ~ has_relapsed, data = rottrain_t,
                            x = TRUE, y = TRUE),
                      full_modelt_formula,
                      direction = "forward", k = 2)
# pam.coxph(rott_sfAIC)
```

```{r}
# model selection may take a while, resulting models are below
rott_sbBIC <- coxph(Surv(start, end, death) ~ age + size + nodes + pgr + has_relapsed,
                    data = rottrain_t, x = TRUE, y = TRUE)
rott_sfAIC <- coxph(Surv(start, end, death) ~ has_relapsed + age + nodes + pgr + size + chemo + grade,
                    data = rottrain_t, x = TRUE, y = TRUE)
```

```{r}
cut_points <- sort(unique(rotterdam_train[rotterdam_test$death == 1,]$dtime))
rottest_t <- survSplit(Surv(dtime, death) ~ ., data = rotterdam_test,
                   cut = cut_points, end = "end", start = "start")
rottest_t$has_relapsed <- rottest_t$end >= rottest_t$rtime & rottest_t$recur == 1
```

## PAM Evaluation on Test Set

```{r}
weiAFT_sbAIC_R2L2 <- as.numeric(unlist(pam.survreg(weiAFT_sbAIC,
                                                   x.mat = rotterdam_train)))
exAFT_sbAIC_R2L2 <- as.numeric(unlist(pam.survreg(exAFT_sbAIC,
                                                   x.mat = rotterdam_train)))
lognormAFT_sbAIC_R2L2 <- as.numeric(unlist(pam.survreg(lognormAFT_sbAIC,
                                                       x.mat = rotterdam_train)))
R2L2_stats <- lapply(list(rot_sfAIC, rot_sfBIC, lasso_temp), function(x) {
  as.numeric(unlist(pam.coxph(x)))
}) %>% 
  do.call(rbind, .) %>%
  # cannot compute R2/L2 for time-dependent models?
  rbind(matrix(rep(NA, 4), 2, 2)) %>% 
  rbind(weiAFT_sbAIC_R2L2, exAFT_sbAIC_R2L2, lognormAFT_sbAIC_R2L2, .) %>% 
  as.data.frame()
colnames(R2L2_stats) <- c("R2_squared", "L2_squared")
PA_stats <- data.frame(
  model = c(
    "Weibull AFT, Stepwise Backward via AIC",
    "Exponential AFT, Stepwise Backward via AIC",
    "Lognormal AFT, Stepwise Backward via AIC",
    "Cox Regression Stepwise Forward Selection via AIC",
    "Cox Regression Stepwise Forward Selection via BIC",
    "Cox Regression LASSO Estimate (10-fold CV)",
    "Cox MH (Time-dependent Relapse), Stepwise Backward via BIC",
    "Cox MH (Time-dependent Relapse), Stepwise Forward via AIC"
  ),
  C_type = c("uno", "uno", "uno", "uno", "uno", "uno", "harrel", "harrel"),
  C_value = c(
    concordance(rot_sfAIC, timewt = "n/G2",
                newdata = rotterdam_test)$concordance,
    concordance(rot_sfBIC, timewt = "n/G2",
                newdata = rotterdam_test)$concordance,
    concordance(lasso_temp, timewt = "n/G2",
                newdata = rotterdam_test)$concordance,
    concordance(weiAFT_sbAIC, timewt = "n/G2",
                newdata = rotterdam_test)$concordance,
    concordance(exAFT_sbAIC, timewt = "n/G2",
                newdata = rotterdam_test)$concordance,
    concordance(lognormAFT_sbAIC, timewt = "n/G2",
                newdata = rotterdam_test)$concordance,
    concordance(rott_sbBIC, newdata = rottest_t)$concordance,
    concordance(rott_sfAIC, newdata = rottest_t)$concordance
  ),
  R2L2_stats
)
rownames(PA_stats) <- NULL
print(PA_stats)
```

### Calibration Plots:

```{r}
t <- rotterdam_train$dtime %>% mean
fiveyear<-5*365
tenyear<-10*365
# link method to SurvMetrics function because calPlot depends on calling 
# predictSurvProb method specifically >:(
predictSurvProb.survreg <- function(object, newdata, times, ...) {
  SurvMetrics::predictSurvProb2survreg(object, newdata, times, ...)
}
myCalPlotSettings <- function(model, legend.label = "Predicted survival",
                              newdata = rotterdam_test, ...) {
  pec::calPlot(model, data = newdata, method = "quantile",
               q = 10, bars=TRUE, type="survival", pseudo=FALSE,
               legend.legend = c(legend.label, "Kaplan-Meier Estimate"), ...)
}
```

## Weibull AFT Calibration Plots

```{r}
myCalPlotSettings(weiAFT_sbAIC, "Weibull AFT Prediction", time = t)
myCalPlotSettings(weiAFT_sbAIC, "Weibull AFT Prediction", time = fiveyear)
myCalPlotSettings(weiAFT_sbAIC, "Weibull AFT Prediction", time = tenyear)
```

## Exponential AFT Calibration Plots

```{r}
myCalPlotSettings(exAFT_sbAIC, "Exponential AFT Prediction", time = t)
myCalPlotSettings(exAFT_sbAIC, "Exponential AFT Prediction", time = fiveyear)
myCalPlotSettings(exAFT_sbAIC, "Exponential AFT Prediction", time = tenyear)
```

## Lognormal AFT Calibration Plots

```{r}
myCalPlotSettings(lognormAFT_sbAIC, "Lognormal AFT Prediction", time = t)
myCalPlotSettings(lognormAFT_sbAIC, "Lognormal AFT Prediction", time = fiveyear)
myCalPlotSettings(lognormAFT_sbAIC, "Lognormal AFT Prediction", time = tenyear)
```

## Cox LASSO Calibration Plots

```{r}
myCalPlotSettings(lasso_temp, "Cox LASSO Prediction",
                  formula = full_model_formula, time = t)
myCalPlotSettings(lasso_temp, "Cox LASSO Prediction",
                  formula = full_model_formula, time = fiveyear)
myCalPlotSettings(lasso_temp, "Cox LASSO Prediction",
                  formula = full_model_formula, time = tenyear)
```

## Cox Stepwise Forward AIC Calibration Plots

```{r}
myCalPlotSettings(rot_sfAIC, "Cox Stepwise Forward AIC Prediction", time = t)
myCalPlotSettings(rot_sfAIC, "Cox Stepwise Forward AIC Prediction", time = fiveyear)
myCalPlotSettings(rot_sfAIC, "Cox Stepwise Forward AIC Prediction", time = tenyear)
```

## Cox Stepwise Forward BIC Calibration Plots

```{r}
myCalPlotSettings(rot_sfBIC, "Cox Stepwise Forward BIC Prediction", time = t)
myCalPlotSettings(rot_sfBIC, "Cox Stepwise Forward BIC Prediction", time = fiveyear)
myCalPlotSettings(rot_sfBIC, "Cox Stepwise Forward BIC Prediction", time = tenyear)
```

## Cox PH Calibration Plot

```{r}
myCalPlotSettings(fit.coxph, "Cox PH Prediction", time = t)
myCalPlotSettings(fit.coxph, "Cox PH Prediction", time = fiveyear)
myCalPlotSettings(fit.coxph, "Cox PH Prediction", time = tenyear)
```

```{r}
calPlot(list("Cox Regression" = fit.coxph), time=t, data=rotterdam_test,
        type="risk")
```

### GREENWOOD-NAM-D'AGOSTINO CALIBRATION TEST

double check this code some more
https://ncook.bwh.harvard.edu/assets/code101316_GND_test_replicable_example.R

```{r}
source(paste0(data_directory, "calibration_chisquare.R"))

#calibration at 5 years

#read the data
d<-rotterdam_test

#we decided we are interested in calibration at 5 years,
#so censor after 5 years
adm.cens=4000
d$fu.time <- pmin(d$futime, adm.cens)
d$status <- ifelse(as.numeric(adm.cens < d$futime), 0, d$death)
nonadm.cens=ifelse(fu.time<adm.cens & status==0,1,0)
mean(d$status)
```
