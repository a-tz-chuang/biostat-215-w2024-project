---
title: "Biostat M215 Final Project"
author: "Rina Arputhasamy, Andrew Chuang, Carolyn Winskill, Kyle Wu"
date: "2024-03-11"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Biostatistics M215: Final Project

## Libraries: 

```{r}
#Relevant libraries:
library(survival)
library(PAmeasures)
library(tidyverse)
library(kableExtra)
library(pec)
library(MASS)
data_directory <- "functions/"
source(paste0(data_directory, "pam.survreg.update.R"))
```

## Data Preparation

```{r data_load}
data(cancer, package = "survival")
n <- nrow(rotterdam)
```

```{r train_test_split}
# train-test split
test_p <- 0.15
set.seed(215) #cw added
test_indx <- sample(n, n * test_p)
rotterdam_test <- rotterdam[test_indx,]
rotterdam_train <- rotterdam[!seq_len(n) %in% test_indx,]
```

## Descriptive Statistics

CW: create a summary table of all potential predictors in dataset (means/medians, frequencies)

## Kaplan Meier Plots

```{r}
km<-survfit(Surv(dtime, death)~1,conf.type="log-log",data=rotterdam)
summary(km)

plot(km,conf.int=F,mark.time=F,
     xlab="time (days)",
     ylab="probability",
     main="Kaplan-Meier estimates of time to death")
```

CW: make plot more visually appealing? add KM plots stratified by predictors like menopausal status, tumor size, differentiation grade, hormonal treatment?

## Log-rank tests 

```{r}
survdiff(Surv(dtime, death)~meno,data=rotterdam)
```
CW: need univariate Cox models to get unadjusted hazard ratios?

## Full Models and Prediction Accuracy Measures (Rotterdam)

### Cox PH and PAM: 

```{r}
# Fit a multiple Cox PH model with age and edema
fit.coxph <- coxph(Surv(dtime, death) ~ age + meno + size + grade + nodes + pgr + er + hormon + chemo, 
                   data = rotterdam_train, x=TRUE,y=TRUE)
summary(fit.coxph)
# R.squared and L.squared of Cox PH model
pam.coxph(fit.coxph)
concordance(fit.coxph, timewt = "n/G2")$concordance
```

### Exponential AFT Model: 

```{r}
fit.exp <- survreg(Surv(dtime, death) ~ age + meno + size + 
                     grade + nodes + pgr + er + hormon + chemo,
                   data = rotterdam_train, dist="exponential",
                   x = TRUE, y = TRUE)
summary(fit.exp)
# R.squared and L.squared of exponential model
# when data has factors (size), need to pass data directly as shown below
pam.survreg(fit.exp, x.mat = rotterdam_train)
concordance(fit.exp, timewt = "n/G2")$concordance
```

### Weibuill AFT Model: 

```{r}
fit.wei <- survreg(Surv(dtime, death) ~ age + meno + size + 
                     grade + nodes + pgr + er + hormon + chemo,
                   data = rotterdam_train, dist="weibull",
                   x = TRUE, y = TRUE)
summary(fit.wei)
# R.squared and L.squared of exponential model
# when data has factors (size), need to pass data directly as shown below
pam.survreg(fit.wei, x.mat = rotterdam_train)
concordance(fit.wei, timewt = "n/G2")$concordance
```

### Lognormal AFT Model: 

```{r}
fit.lognormal <- survreg(Surv(dtime, death) ~ age + meno + size + 
                           grade + nodes + pgr + er + hormon + chemo, 
                   data = rotterdam_train, dist="lognormal",
                   x = TRUE, y = TRUE)
summary(fit.lognormal)
# R.squared and L.squared of the lognormal model
pam.survreg(fit.lognormal, x.mat = rotterdam_train)
concordance(fit.lognormal, timewt = "n/G2")$concordance
```

## Model Selection

We first consider variable selection under the Cox proportional hazards model.

Stepwise forward selection via AIC:
```{r AIC_selection}
full_model_formula <- Surv(dtime, death) ~ age + meno + size + 
                           grade + nodes + pgr + er + hormon + chemo
null_model_formula <- Surv(dtime, death) ~ 1
rot_sfAIC <- stepAIC(coxph(null_model_formula, data = rotterdam_train,
                            x = TRUE, y = TRUE),
                     full_model_formula,
                     direction = "forward", k = 2)
summary(rot_sfAIC)
pam.coxph(rot_sfAIC)
concordance(rot_sfAIC, timewt = "n/G2")$concordance
```

Stepwise backward selection via AIC:
```{r AIC_selection}
rot_sbAIC <- stepAIC(coxph(full_model_formula,
                             data = rotterdam_train,
                             x = TRUE, y = TRUE),
                     full_model_formula,
                     direction = "backward", k = 2)

summary(rot_sbAIC)
pam.coxph(rot_sbAIC)
concordance(rot_sbAIC, timewt = "n/G2")$concordance
```

Forward and backward selection via AIC result in the same model.

Stepwise forward selection via BIC:
```{r BIC_forward_selection}
rot_sfBIC <- stepAIC(coxph(null_model_formula, data = rotterdam_train,
                           x = TRUE, y = TRUE),
                     full_model_formula,
                     direction = "forward", k = log(n))
summary(rot_sfBIC)
pam.coxph(rot_sfBIC)
concordance(rot_sfBIC, timewt = "n/G2")$concordance
```

Stepwise backward selection via BIC:
```{r BIC_backward_selection}
rot_sbBIC <- stepAIC(coxph(full_model_formula,
                           data = rotterdam_train,
                           x = TRUE, y = TRUE),
                     full_model_formula,
                     direction = "backward", k = log(n))
summary(rot_sbBIC)
pam.coxph(rot_sbBIC)
concordance(rot_sbBIC, timewt = "n/G2")$concordance
```

We fit a LASSO model and attach the resulting coefficients to a coxph object so that we can call survival::concordance:

```{r}
library(ncvreg)
X <- rotterdam_train[, c("age", "meno", "size", "grade", "nodes", "pgr",
                         "er", "hormon", "chemo")]
X$`size20-50` <- ifelse(X$size == "20-50", 1, 0)
X$`size>50` <- ifelse(X$size == ">50", 1, 0)
X$size <- NULL
y <- Surv(rotterdam_train$dtime, rotterdam_train$death)
rot_cvlasso <- cv.ncvsurv(X, y,
                          nfolds = 10, nlambda = 10, penalty = "lasso")
rot_lasso <- ncvsurv(X, y, penalty = "lasso", lambda = rot_cvlasso$lambda.min)
lasso_beta <- coef(rot_lasso)
names(lasso_beta) <- colnames(X)
lasso_temp <- coxph(full_model_formula, data = rotterdam_train)
lasso_beta <- lasso_beta[match(names(coef(lasso_temp)), names(lasso_beta))]
lasso_temp$coefficients <- lasso_beta
concordance(lasso_temp, timewt = "n/G2", newdata = rotterdam_train)
```

## Time-dependent Covariates

Suppose we add the time-dependent relapse indicator as a covariate.

```{r}
cut_points <- sort(unique(rotterdam_train[rotterdam_train$death == 1,]$dtime))
rottrain_t <- survSplit(Surv(dtime, death) ~ ., data = rotterdam_train,
                   cut = cut_points, end = "end", start = "start")
rottrain_t$has_relapsed <- rottrain_t$end >= rottrain_t$rtime & rottrain_t$recur == 1
full_modelt_formula <- Surv(start, end, death) ~ age + meno + size + 
  grade + nodes + pgr + 
  er + hormon + chemo + has_relapsed
rott_coxph <- coxph(full_modelt_formula, data = rottrain_t, x = TRUE, y = TRUE)
rott_sbBIC <- stepAIC(rott_coxph,
                      full_modelt_formula,
                      direction = "backward", k = log(n))
# model selection may take a while, resulting model is below
# rott_sbBIC <- coxph(Surv(start, end, death) ~ age + size + nodes + pgr + has_relapsed,
#                     data = rottrain_t, x = TRUE, y = TRUE)
```

```{r}
cut_points <- sort(unique(rotterdam_train[rotterdam_test$death == 1,]$dtime))
rottest_t <- survSplit(Surv(dtime, death) ~ ., data = rotterdam_test,
                   cut = cut_points, end = "end", start = "start")
rottest_t$has_relapsed <- rottest_t$end >= rottest_t$rtime & rottest_t$recur == 1
```


### Evaluation on Test Set

```{r}
concordance(rot_sfAIC, timewt = "n/G2", newdata = rotterdam_test)
concordance(rot_sfBIC, timewt = "n/G2", newdata = rotterdam_test)
concordance(lasso_temp, timewt = "n/G2", newdata = rotterdam_test)
concordance(rott_sbBIC, newdata = rottest_t)
```


### Calibration Plot for Cox PH:

```{r}
t <- rotterdam$dtime %>% mean

calPlot(fit.coxph, time=t, data=rotterdam, method = "quantile", q=5,
        bars=TRUE, type="survival", pseudo=FALSE)
```

CW: write function for calibration plot that can do both Cox and AFT models
